<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何寻找电影资源--萌新必读]]></title>
    <url>%2F2018%2F07%2F20%2F20180706%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E7%94%B5%E5%BD%B1%E8%B5%84%E6%BA%90%20%2F</url>
    <content type="text"><![CDATA[在当今版权大道横行的今天如何寻找电影资源呢？不管你是萌新还是小白，走过路过千万被错过，对于支持盗版还是正版，我个人觉得有条件的可以去支持下正版，比如一些高质量的电影 战狼、红海行动、复仇者联盟等电影还是会去电影支持下，再者有时候下载些自己喜欢的电影收藏，那么就不要错过了。网络冲浪冲浪十余载，今天我就分享给大家。 工欲善其事必先利其器–下载工具 话说这网络江湖十余载，下载工具可是风风雨雨层层出不穷，先从快车横空出世，再到迅雷不及掩耳之势杀出来的迅雷，再到如旋风一般的QQ旋风下载，如今也只剩下迅雷一家独大。不过这些都是大家熟知的国内下载 工具还有些大家比较少见的过国外的工具。如μTorrent、Qbittorrent、IDM等，下面就给大家介绍下这些工具优略。 迅雷：主要下载一些正版资源、磁力链接等不敏感的资源下载的话还是很快，总体来说还是比较全能，就是广告太多，有条件可以买vip用vip专享版还是不错的，或者使用精简版或者和谐版，这个大家自行百度/谷歌。 IMD：IDM是我个人比较常用的工具，下载百度网盘资源（不限速）其他一些网页资源，都能爬出来，如YouTube等一些网站上资源，缺点是不能下载磁力资源、种子资源。 μTorrent、Qbittorrent：是当前比较好用的BT下载工具、其他什么的比特、快驴什么都是渣渣。缺点BT好用、其他一般般，下载完成的资源需要做种(即分享给其他下载P2P技术，人人为我我为人人） –萌新篇 对于比较省事的萌新来说，直接购买腾讯、优酷、爱奇艺VIP即可免广告蓝光观影，缺点是各家有自己资源、会员伤不起啊。腾讯拥有比较多的优质的电影动漫等，爱奇艺也差不多，优酷资源相对质量不高。但对于学生党又不怕麻烦 那就选择VIP解析，直接把各大网站的VIP链接，这类的网站很多大家可以自行百度搜索“VIP解析”关键字 VIP解析：http://tv.dsqndh.com/ –菜鸡篇 对于不怕麻烦对于画质又有点要求的同学，下载回来看绝对是个不错的方法至少不会关键时刻卡住 小调网：https://www.xiaopian.com/ 飘花电影：https://www.piaohua.com/ BT电影天堂：http://www.btbtdy.com/ 6V电影 ：http://www.6vdy.com/ 迅影网：http://www.xunyingwang.com/s 神马电影网：http://www.9rsm.com/ 搬运工：http://www.banyungong.org/ 电影FM：http://dianying.fm/discovery/rosso-come-il-cielo/ 圣城家园：http://www.cnscg.com/ ＢＴ首发站：http://www.btshoufa.com/forum.php 思享ＢＴ电影：http://ibzz.39cs.com/ LOL电影天堂：https://www.loldytt.com/ –老司机篇 对于一些喜欢收藏电影，对电影画质、声效有要求的同学来说，这些资源来说，必须具备以下条件，硬盘：4T起步，网速：50M起步，硬盘可以是给自己的电脑装一个大的，或者买个NAS来下载，比较流行的是群晖、威联通 我用的是入门级的威联通NAS,也可以自己组装，安装上黑群晖或者黑威联通都是可以的，这些就不展开讲了，大家可以自行百度，我有的是威联通入门的（PS：图省事 主要下载4k电影） 电驴贡献共享资源网站：http://www.ed2000.com/ 3D电影资源：http://bbs.cnliti.com/ 4K中国：http://www.hao4k.com/ 4K宅极客：https://www.zhaiiker.com/ 韩国电影资源网站:http://www.totoria.net/ (很不错网站，速度快质量高，可以用谷歌翻译) 海盗湾：https://thepiratebay3.org/（神奇网站）还有些其他BT搜索网站大家自行谷歌]]></content>
      <categories>
        <category>分享福利</category>
        <category>资源分享</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义时间选择器]]></title>
    <url>%2F2018%2F07%2F09%2F20180709%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[自定义时间选择器 这里使用符合控件的形式来编写，过于复杂这难于理解，能够高效实现需求。 ¶一、时间选择器需求分析 这里主要作用是明确却所需要的功能，才能确定所需要的的技术，方便提前阅读相关资料 ¶二、技术分析 创建显示弹窗，采用的DialogFragment,PopWindow的话，太多问题了，对于有虚拟按键的剧中显示，背景透明度等不好控制，而且官方推荐使用DialogFragment 能够有效关系生命周期 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Bundle bundle = new Bundle(); bundle.putString(TimerPickDialogFragment.TITLE, &quot;行程时间&quot;); bundle.putLong(TimerPickDialogFragment.TIME_START, System.currentTimeMillis()); bundle.putLong(TimerPickDialogFragment.TIME_END, System.currentTimeMillis()); new TimerPickDialogFragment().setOnTimeClickListener(new TimerPickDialogFragment.OnTimeClickListener() &#123; @Override public void onClick(View view, TimerPickDialogFragment timerPickDialogFragment) &#123; switch (view.getId()) &#123; case R.id.tvTimerPickerCancel: timerPickDialogFragment.dismiss(); break; case R.id.tvTimerPickerSure: timerPickDialogFragment.dismiss(); break; default: break; &#125; &#125; &#125;).setOnStartCurrentDateListener(new TimerPickDialogFragment.OnStartCurrentDateListener() &#123; @Override public void onStartCurrentDate(View view, long date, TimerPickDialogFragment timerPickDialogFragment) &#123; &#125; &#125;).setOnEndCurrentDateListener(new TimerPickDialogFragment.OnEndCurrentDateListener() &#123; @Override public void onEndCurrentDate(View view, long date, TimerPickDialogFragment timerPickDialogFragment) &#123; &#125; &#125;).addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;).isShowRemark(true) .updateText(&quot;时间选择器&quot;) .setBundle(bundle) .show(getFragmentManager(), &quot;Time&quot;); 这里首先要对DialogFragment控件熟知，不懂得同学可以先移步官方文档，这里也对一些背景设定做下说明 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; // 修改显示的背景色 Window window = getDialog().getWindow(); window.setBackgroundDrawable(new ColorDrawable(ContextCompat.getColor(getActivity(), R.color.c_99000000))); // 修改输入法对弹窗的影响 window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE); View view = inflater.inflate(R.layout.popwin_time_picker, container, false); unbinder = ButterKnife.bind(this, view); if (bundle != null) &#123; timeStart = bundle.getLong(TIME_START); timeEnd = bundle.getLong(TIME_END); tvTimerPickerTitle.setText(bundle.getString(TITLE)); &#125; else if (timeStart &lt;= 0 &amp;&amp; timeEnd &lt;= 0) &#123; timeStart = timeEnd = Calendar.getInstance().getTimeInMillis(); &#125; if (textWatcher != null) &#123; edTimerPickerRemark.addTextChangedListener(textWatcher); &#125; if (isShow) &#123; if (!TextUtils.isEmpty(remark)) &#123; edTimerPickerRemark.setText(remark); &#125; tvTimerPickerRemarkTitle.setVisibility(View.VISIBLE); edTimerPickerRemark.setVisibility(View.VISIBLE); &#125; else &#123; tvTimerPickerRemarkTitle.setVisibility(View.GONE); edTimerPickerRemark.setVisibility(View.GONE); &#125; /** * 设置不可点击 */ // pvTimerPickerStart.setWheelEnabled(false); //时间回调 pvTimerPickerStart.setOnCurrentDateListener(new PickView.OnCurrentDateListener() &#123; @Override public void onCurrentDate(View view, long date) &#123; if (onStartCurrentDateListener != null) &#123; onStartCurrentDateListener.onStartCurrentDate(view, date, TimerPickDialogFragment.this); &#125; &#125; &#125;); pvTimerPickerEnd.setOnCurrentDateListener(new PickView.OnCurrentDateListener() &#123; @Override public void onCurrentDate(View view, long date) &#123; if (onEndCurrentDateListener != null) &#123; onEndCurrentDateListener.onEndCurrentDate(view, date, TimerPickDialogFragment.this); &#125; &#125; &#125;); pvTimerPickerStart.updateDate(timeStart); pvTimerPickerEnd.updateDate(timeEnd); return view; &#125; 设计具体的滚动Item 时间选择器有年月日时分，五个大Item 组合而成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275package wudiplk.com.mycustomview.custom_view;import android.content.Context;import android.os.Handler;import android.os.Message;import android.support.annotation.Nullable;import android.util.AttributeSet;import android.view.View;import android.widget.LinearLayout;import java.util.ArrayList;import java.util.Calendar;import java.util.Date;import java.util.List;/** * @author Wudi * @date 2018/1/16 */public class PickView extends LinearLayout &#123; private Context context; private WheelView rvYear, rvMonth, rvDay, rvHour, rvMinute; private List&lt;String&gt; yearList = new ArrayList&lt;&gt;(); private List&lt;String&gt; monthList = new ArrayList&lt;&gt;(); private List&lt;String&gt; dayList = new ArrayList&lt;&gt;(); private List&lt;String&gt; hourList = new ArrayList&lt;&gt;(); private List&lt;String&gt; minuteList = new ArrayList&lt;&gt;(); private Calendar calendar; private int yearPosition, monthPosition, dayPosition, hourPosition, minutePosition; public PickView(Context context) &#123; super(context); this.context = context; &#125; public PickView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); this.context = context; &#125; public PickView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.context = context; &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (calendar == null) &#123; calendar = Calendar.getInstance(); &#125; Handler handler = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; initView(); return false; &#125; &#125;); handler.sendEmptyMessage(1); &#125; private void initView() &#123; setOrientation(HORIZONTAL); // 初始化时间 initDate(); // 初始化控件 rvYear = new WheelView(context, calendar, Calendar.YEAR, getMeasuredWidth(), getMeasuredHeight(), yearList, yearPosition); rvMonth = new WheelView(context, calendar, Calendar.MONTH, getMeasuredWidth(), getMeasuredHeight(), monthList, monthPosition); rvDay = new WheelView(context, calendar, Calendar.DAY_OF_MONTH, getMeasuredWidth(), getMeasuredHeight(), dayList, dayPosition); rvHour = new WheelView(context, calendar, Calendar.HOUR_OF_DAY, getMeasuredWidth(), getMeasuredHeight(), hourList, hourPosition); rvMinute = new WheelView(context, calendar, Calendar.MINUTE, getMeasuredWidth(), getMeasuredHeight(), minuteList, minutePosition); rvYear.setOnCurrentItemListener(new WheelView.OnCurrentItemListener() &#123; @Override public void onCurrent(int position, String content) &#123; if (onCurrentDateListener != null) &#123; int year = Integer.parseInt(content.replace(&quot;年&quot;, &quot;&quot;)); calendar.set(Calendar.YEAR, year); onCurrentDateListener.onCurrentDate(PickView.this, calendar.getTimeInMillis()); &#125; &#125; &#125;); rvMonth.setOnCurrentItemListener(new WheelView.OnCurrentItemListener() &#123; @Override public void onCurrent(int position, String content) &#123; if (onCurrentDateListener != null) &#123; // -1 由于系统计算月份是由0开始 int month = Integer.valueOf(content.replace(&quot;月&quot;, &quot;&quot;)) - 1; calendar.set(Calendar.MONTH, month); // 更新这个月的天数 dayPosition = 0; getDas(calendar.get(Calendar.YEAR), month + 1, calendar.get(Calendar.DAY_OF_MONTH)); rvDay.updateData(dayList, dayPosition); onCurrentDateListener.onCurrentDate(PickView.this, calendar.getTimeInMillis()); &#125; &#125; &#125;); rvDay.setOnCurrentItemListener(new WheelView.OnCurrentItemListener() &#123; @Override public void onCurrent(int position, String content) &#123; if (onCurrentDateListener != null) &#123; int day = Integer.valueOf(content.replace(&quot;日&quot;, &quot;&quot;)); calendar.set(Calendar.DAY_OF_MONTH, day); onCurrentDateListener.onCurrentDate(PickView.this, calendar.getTimeInMillis()); &#125; &#125; &#125;); rvHour.setOnCurrentItemListener(new WheelView.OnCurrentItemListener() &#123; @Override public void onCurrent(int position, String content) &#123; if (onCurrentDateListener != null) &#123; int hour = Integer.valueOf(content.replace(&quot;时&quot;, &quot;&quot;)); calendar.set(Calendar.HOUR_OF_DAY, hour); onCurrentDateListener.onCurrentDate(PickView.this, calendar.getTimeInMillis()); &#125; &#125; &#125;); rvMinute.setOnCurrentItemListener(new WheelView.OnCurrentItemListener() &#123; @Override public void onCurrent(int position, String content) &#123; if (onCurrentDateListener != null) &#123; int minute = Integer.valueOf(content.replace(&quot;分&quot;, &quot;&quot;)); calendar.set(Calendar.MINUTE, minute); onCurrentDateListener.onCurrentDate(PickView.this, calendar.getTimeInMillis()); &#125; &#125; &#125;); // 添加所有初始化后的页面 addView(rvYear, 0); addView(rvMonth, 1); addView(rvDay, 2); addView(rvHour, 3); addView(rvMinute, 4); if (!isEnable) &#123; rvYear.setWheelEnable(isEnable); rvMonth.setWheelEnable(isEnable); rvDay.setWheelEnable(isEnable); rvHour.setWheelEnable(isEnable); rvMinute.setWheelEnable(isEnable); &#125; &#125; /** * 设置初始时间 * * @param updateDate */ public void updateDate(long updateDate) &#123; if (updateDate != 0) &#123; calendar = Calendar.getInstance(); calendar.setTime(new Date(updateDate)); &#125; &#125; /** * 获取获取具体年份的天数,如果是初始化 当前的年月日 * 如果是获取某年某月的天数day 默认为1 * * @param year * @param month * @return */ public void getDas(int year, int month, int day) &#123; Calendar newCalendar = Calendar.getInstance(); newCalendar.set(Calendar.YEAR, year); newCalendar.set(Calendar.MONTH, month - 1); newCalendar.set(Calendar.DATE, 1); newCalendar.roll(Calendar.DATE, -1); int days = newCalendar.get(Calendar.DATE); dayList.clear(); for (int i = 1; i &lt;= days; i++) &#123; if (i &lt; 10) &#123; dayList.add(&quot;0&quot; + i + &quot;日&quot;); &#125; else &#123; dayList.add(i + &quot;日&quot;); &#125; if (i == day) &#123; dayPosition = i - 1; &#125; &#125; &#125; /** * 初始化时间数据 */ private void initDate() &#123; int year = calendar.get(Calendar.YEAR); int month = calendar.get(Calendar.MONTH); int day = calendar.get(Calendar.DAY_OF_MONTH); int hour = calendar.get(Calendar.HOUR_OF_DAY); int minute = calendar.get(Calendar.MINUTE); // 初始化年数 和当前年 for (int i = year - 50; i &lt;= (year + 100); i++) &#123; if (i == year) &#123; yearPosition = yearList.size(); &#125; yearList.add(i + &quot;年&quot;); &#125; // 初始化月份 和当前月 for (int i = 1; i &lt;= 12; i++) &#123; if (i == month) &#123; monthPosition = i; &#125; monthList.add(i + &quot;月&quot;); &#125; // 初始化天数 和当前天 getDas(year, month + 1, day); // 初始化小时数 和当小时 for (int i = 0; i &lt; 24; i++) &#123; if (hour == i) &#123; hourPosition = i; &#125; if (i &lt; 10) &#123; hourList.add(&quot;0&quot; + i + &quot;时&quot;); &#125; else &#123; hourList.add(i + &quot;时&quot;); &#125; &#125; // 初始化分钟数 和当分钟 for (int i = 0; i &lt; 12; i++) &#123; if (minute / 5 == i) &#123; minutePosition = i; calendar.set(Calendar.MINUTE, i * 5); &#125; if (i &lt; 2) &#123; minuteList.add(&quot;0&quot; + i * 5 + &quot;分&quot;); &#125; else &#123; minuteList.add(i * 5 + &quot;分&quot;); &#125; &#125; &#125; public interface OnCurrentDateListener &#123; /** * 获取当前的日期 * * @param view * @param date */ void onCurrentDate(View view, long date); &#125; private OnCurrentDateListener onCurrentDateListener; public void setOnCurrentDateListener(OnCurrentDateListener onCurrentDateListener) &#123; this.onCurrentDateListener = onCurrentDateListener; &#125; private boolean isEnable = true; public void setWheelEnabled(boolean b) &#123; this.isEnable = b; &#125;&#125; 每个Item 都是由一个RecycleView（WheelView)，关键代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/** * 初始化内部控件 */ private void init() &#123; currentPosition = initPosition; // 初始化滚动器的宽高 oneHeight = (parentHeight - DensityUtils.dp2px(context, 4)) / 3; oneWidth = parentWidth / 5; final int padding = dp2px(3); LayoutParams params = new LayoutParams(oneWidth, parentHeight); setLayoutParams(params); this.setPadding(padding, 0, padding, 0); // 设置内部控件左右两边的空隙 mRecyclerView = new RecyclerView(context); mRecyclerView.setOverScrollMode(OVER_SCROLL_NEVER); LayoutParams layoutParams = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); layoutParams.addRule(RelativeLayout.CENTER_IN_PARENT, TRUE); // 指定显示三行数据 layoutManager = new LinearLayoutManager(context) &#123; @Override public void onMeasure(RecyclerView.Recycler recycler, RecyclerView.State state, int widthSpec, int heightSpec) &#123; if (getChildCount() &gt; 0) &#123; View firstChildView = recycler.getViewForPosition(0); measureChild(firstChildView, widthSpec, heightSpec); setMeasuredDimension(MeasureSpec.getSize(widthSpec), firstChildView.getMeasuredHeight() * 3 - DensityUtils.dp2px(context, 4)); &#125; else &#123; super.onMeasure(recycler, state, widthSpec, heightSpec); &#125; &#125; &#125;; mRecyclerView.setLayoutManager(layoutManager); // 添加数据 itemAdapter = new ItemAdapter(); mRecyclerView.setAdapter(itemAdapter); // 滑动监听获取当前的item mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; RecyclerView.LayoutManager layoutManager; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); // now State 0静止,没有滚动 1 正在被外部拖拽,一般为用户正在用手指滚动 2 自动滚动开始 if (newState == 0) &#123; layoutManager = recyclerView.getLayoutManager(); LinearLayoutManager linearLayoutManager = (LinearLayoutManager) layoutManager; if (linearLayoutManager.findLastCompletelyVisibleItemPosition() == currentPosition) &#123; // TODO &#125; else if (onCurrentItemListener != null) &#123; int nowPosition = (linearLayoutManager.findLastCompletelyVisibleItemPosition()); String text = stringList.get(nowPosition % stringList.size()) .replace(&quot;年&quot;, &quot;&quot;) .replace(&quot;月&quot;, &quot;&quot;) .replace(&quot;日&quot;, &quot;&quot;) .replace(&quot;时&quot;, &quot;&quot;) .replace(&quot;分&quot;, &quot;&quot;); // 判断是否是过去的日期 if (wheelType == Calendar.MONTH) &#123; selectCalendar.set(wheelType, Integer.valueOf(text) - 1); &#125; else &#123; selectCalendar.set(wheelType, Integer.valueOf(text)); &#125; // 判断是否是小于当前时间 if (selectCalendar.getTimeInMillis() &gt;= System.currentTimeMillis()) &#123; onCurrentItemListener.onCurrent(nowPosition % stringList.size(), stringList.get(nowPosition % stringList.size())); layoutManager.scrollToPosition(nowPosition + 1); itemAdapter.notifyItemChanged(nowPosition, 0); itemAdapter.notifyItemChanged(currentPosition, 1); currentPosition = nowPosition; &#125; else &#123; // 判断是向上还是线下 isUpOrDown&gt;向下，isUpOrDown&lt;0向上 if (isUpOrDown &gt; 0) &#123; currentPosition = initPosition; // 由于滚动有些偏差，使用scrollToPositionWithOffset 来滚动 linearLayoutManager.scrollToPositionWithOffset(currentPosition - 1, -DensityUtils.dp2px(context, 3)); itemAdapter.notifyItemChanged(currentPosition, 0); &#125; else &#123; currentPosition = initPosition; linearLayoutManager.scrollToPositionWithOffset(currentPosition - 1, -DensityUtils.dp2px(context, 3)); itemAdapter.notifyItemChanged(currentPosition, 0); &#125; &#125; &#125; &#125; else &#123; itemAdapter.notifyItemChanged(currentPosition, 1); &#125; &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); isUpOrDown = dy; &#125; &#125;); // 添加滚动器的的双杠线 View topLineView = new View(context); View bottomLineView = new View(context); topLineView.setBackgroundColor(ContextCompat.getColor(context, R.color.c_e5e5e5)); bottomLineView.setBackgroundColor(ContextCompat.getColor(context, R.color.c_e5e5e5)); LayoutParams topLayoutParam = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, dp2px(1)); topLayoutParam.setMargins(0, oneHeight, 0, 0); topLayoutParam.addRule(RelativeLayout.ALIGN_PARENT_TOP, RelativeLayout.TRUE); LayoutParams bottomLayoutParams = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, dp2px(1)); bottomLayoutParams.setMargins(0, oneHeight * 2, 0, 0); bottomLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_TOP, RelativeLayout.TRUE); // 滑动到初始位置 -1是为了移动到中间位置 layoutManager.scrollToPosition(stringList.size() * 1000 + initPosition - 1); currentPosition = stringList.size() * 1000 + initPosition; // 添加所有初始化后的空间 addView(mRecyclerView, layoutParams); addView(topLineView, topLayoutParam); addView(bottomLineView, bottomLayoutParams); &#125;]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自定义仪表倒计时]]></title>
    <url>%2F2018%2F07%2F07%2F20180707%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%AA%E8%A1%A8%E5%80%92%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[如何自定义仪表倒计时 对于复杂的自定义控件，主要做到化繁为简、一步步剖析，就如同车间生产线一样，分解成一个个零件生产，然后再组装调试，达到自己期望的目标；而不是盲目的去写代码，先要有整体的构思 然后再去实践；效率事半功倍，对于所需要的知识也可以在实践前了解清楚，这样避免了所用的方法或者函数不熟悉，导致时间浪费了 ¶设计结构 ¶设计所需知识点梳理 ¶详细代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282package wudiplk.com.mycustomview.custom_view;import android.content.Context;import android.graphics.Canvas;import android.graphics.Paint;import android.graphics.PixelFormat;import android.graphics.Rect;import android.os.Handler;import android.os.Message;import android.support.v4.content.ContextCompat;import android.util.AttributeSet;import android.view.Gravity;import android.view.SurfaceHolder;import android.view.SurfaceView;import android.view.View;import android.widget.RelativeLayout;import android.widget.TextView;import wudiplk.com.mycustomview.R;import wudiplk.com.mycustomview.util.DensityUtils;/** * Created by Wu di on 2017/9/6. * Description: */public class CountDownTimer extends RelativeLayout &#123; private Context context; /** * 前景、背景形状 */ private BgView bgView; private ForeView foreView; /** * 中间文字 */ private TextView tvTimer, tvSecondTimer; private int radius, rectWith, rectHeight; private Rect rect; private int time =6; private Handler handler = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; tvTimer.setText(&quot;&quot; + time); return false; &#125; &#125;); public CountDownTimer(Context context) &#123; super(context); this.context = context; init(); &#125; public CountDownTimer(Context context, AttributeSet attrs) &#123; super(context, attrs); this.context = context; init(); &#125; public CountDownTimer(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.context = context; init(); &#125; private void init() &#123; // 定义形状 rectWith = DensityUtils.dp2px(context, 3); rectHeight = DensityUtils.dp2px(context, 20); // 中间文字 tvTimer = new TextView(context); tvTimer.setTextColor(ContextCompat.getColor(context, R.color.c_FF9E00)); tvTimer.setTextSize(100); tvTimer.setGravity(Gravity.CENTER); tvTimer.setText(time + &quot;&quot;); RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT); layoutParams.addRule(RelativeLayout.CENTER_IN_PARENT, RelativeLayout.TRUE); addView(tvTimer, layoutParams); // 添加字符“秒”的位置 tvSecondTimer = new TextView(context); tvSecondTimer.setTextColor(ContextCompat.getColor(context, R.color.c_FF9E00)); tvSecondTimer.setTextSize(22); tvSecondTimer.setText(&quot;秒&quot;); layoutParams = new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT); layoutParams.setMargins(DensityUtils.dp2px(context, 145), DensityUtils.dp2px(context, 130), 0, 0); addView(tvSecondTimer, layoutParams); // 添加到容器 foreView = new ForeView(context); addView(foreView); bgView = new BgView(context); addView(bgView); &#125; /** * 测量获取屏幕的宽高 * * @param w * @param h * @param oldw * @param oldh */ @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); radius = getMeasuredWidth() / 2; rect = new Rect(); rect.left = radius - rectWith; rect.right = radius + rectWith; rect.top = 0; rect.bottom = rectHeight; &#125; private boolean isDraw = false; /** * 背景形状 */ private class BgView extends View &#123; private Paint rectPaint; public BgView(Context context) &#123; super(context); rectPaint = new Paint(); rectPaint.setStyle(Paint.Style.FILL); rectPaint.setColor(ContextCompat.getColor(context, R.color.c_5A492F)); &#125; @Override protected void onDraw(Canvas canvas) &#123; if (!isDraw) &#123; for (int i = 0; i &lt; 60; i++) &#123; canvas.rotate(6, radius, radius); canvas.drawRect(rect, rectPaint); canvas.save(); &#125; isDraw = true; &#125; &#125; &#125; /** * 完成的回掉接口 */ public interface OnFinishListener &#123; /** * 完成结束 */ void onFinish(); &#125; private OnFinishListener onFinishListener; public void setOnFinishListener(OnFinishListener onFinishListener) &#123; this.onFinishListener = onFinishListener; &#125; /** * 倒计时开始 */ public void onStart() &#123; foreView.timerThread.isStop = false; foreView.timerThread.start(); &#125; /** * 倒计时结束 */ public void onStop() &#123; if (foreView.timerThread != null) &#123; foreView.timerThread.onStop(); &#125; &#125; /** * 前面倒计时动画 */ protected class ForeView extends SurfaceView implements SurfaceHolder.Callback &#123; private Context context; private SurfaceHolder mSurfaceHolder; private Paint forePaint; private TimerThread timerThread; public ForeView(Context context) &#123; super(context); this.context = context; mSurfaceHolder = getHolder(); mSurfaceHolder.addCallback(this); mSurfaceHolder.setFormat(PixelFormat.TRANSLUCENT); setZOrderOnTop(true); forePaint = new Paint(); forePaint.setStyle(Paint.Style.FILL); forePaint.setColor(ContextCompat.getColor(context, R.color.c_FFB700)); timerThread = new ForeView.TimerThread(); &#125; @Override public void surfaceCreated(final SurfaceHolder surfaceHolder) &#123; // 自动开始 timerThread.start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; &#125; /** * 倒计时动画更新线程 */ private class TimerThread extends Thread &#123; private boolean isStop = false; public TimerThread() &#123; super(); &#125; @Override public void run() &#123; while (time &gt; 0 &amp;&amp; !isStop &amp;&amp; mSurfaceHolder != null) &#123; for (int i = 0; i &lt;= 31; i++) &#123; Canvas canvas = mSurfaceHolder.lockCanvas(); if (canvas == null) &#123; break; &#125; // 重绘进度 for (int d = 0; d &lt;= i; d++) &#123; canvas.drawRect(rect, forePaint); canvas.rotate(-6, radius, radius); canvas.drawRect(rect, forePaint); canvas.rotate(-6, radius, radius); &#125; mSurfaceHolder.unlockCanvasAndPost(canvas); // 暂停时间 try &#123; Thread.sleep(34); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; time--; // 当旋转一圈改变进度条颜色 handler.sendMessage(new Message()); if (time % 2 == 0) &#123; forePaint.setColor(ContextCompat.getColor(context, R.color.c_5A492F)); &#125; else &#123; forePaint.setColor(ContextCompat.getColor(context, R.color.c_FFB700)); &#125; &#125; if (onFinishListener != null) &#123; onFinishListener.onFinish(); &#125; &#125; public void onStop() &#123; isStop = true; &#125; &#125; &#125;&#125; 相关资料：https://www.jianshu.com/p/b037249e6d31 Demo:https://github.com/wudiplk/MyCustomView]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>仪表倒计时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建个人博客--终极指南]]></title>
    <url>%2F2018%2F07%2F06%2F20180705%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言 之前搭建博客思考了很久，大学时做过网站后来找工作了就不了了之了，现在想起来挺可惜的。 方案一：自己写的话，博客可以根据自己的内容修改，比较自由但时间成本高,效益差。 方案二：用大神的博客框架、简单易上手、可修改性差，但功能丰富齐全，时间成本低。 方案三：用别人框架，自己修改下（都是泪啊）。对于踩过坑的我来说还是第二种省事。毕竟文章内容质量胜于 网站的表现形式，虽然说丰富的功能根据个性（PS：个人观点）下面就整理一下搭建博客的流程以及参考的资料，怕久了自己也忘记了，毕竟过来了，就总得留下些什么。 ¶准备工作 一、 对于萌新来说，可以先看下以下参考资料： 建站知识：https://juejin.im/entry/58c62279ac502e006209eb4a 博客博客框架：http://topspeedsnail.com/static-website-generators_or_tools/ ¶开始步骤 一、 注册github账号和创建库 https://github.com/ 二、 配置Hexo Hexo比较友好有自己的官方网站：https://hexo.io/zh-cn/docs/ 三、将本地Hexo站点部署到GitHubPages 设置Git的账号密码(即运行git界面 右击菜单） 打开命令行，键入以下命令，其中，字符串中的内容替换为你自己的信息，这里为了清晰一致，建议使用 GitHub 账户相同的配置信息 12git config --global user.name &quot;yourname&quot; git config --global user.email &quot;youremail&quot; 创建 SSH Key 在出现的 OpenSSH 界面，点击右上角的 Generate Key 以创建 SSH Key。注意，期间会让你输入密码两次，这个密码是本地 Git 与远程 Git 通信时要用到的，要牢牢记住。 OpenSSH 创建好的 SSH Key，会被存储到为一个私钥文件和一个公钥文件；如果是 Windows 操作系统的话，则他们位于 ./c/Users/pcusername/.ssh 路径下，名称分别是 id_rsa 和 id_rsa.pub 3.远程 GitHub 本地 Git 与远程 GitHub 通信 命令行键入以下命令： $ ssh -T git@github.com Enter passphrase for key ‘/c/Users/pcusername/.ssh/id_rsa’: 当键入以上命令回车后，会出现让我们输入密码的提示，这个密码就是刚刚我们使用 Open SSH 创建 SSH Key 时所输入的密码。 依赖 为了正常部署到远程 Git 仓库，我们还需要先安装一个 Hexo 插件 hexo-deployer-git 1$ npm install hexo-deployer-git --save 配置 由于是部署到远程的 Git 仓库，所以我们需要修改一些配置参数以使其符合针对 Git 的部署配置。 使用文本编辑器打开站点文件夹根目录下的 _config.yml 文件，修改其 deploy 字段之后的内容 12345deploy: type: git repo: git@github.com:你的GitHub用户名/你的GitHub用户名.github.io.git brandh: master messge: 其中，各个参数意义如下： repo ：要部署的远程 Git 仓库地址 branch ：仓库分支名称，程序会自动检测，如果你创建的仓库没有做过修改，那么该值应该就是master message ：自定义 Git 的本次 commit 信息（Hexo会按照一定默认生成） 部署 1$ hexo deploy hexo clear (清理缓存) hexo s debug (编译模式) hexo g hexo d hexo d -g ¶四、动态域名绑定 计入阿里云后台 进入解析域名 添加域名解析 其中185.199.110.153 是ping https://github.com/wudiplk/wudiplk.github.io 网页，至于如何ping 自行百度 进入https://github.com/wudiplk/wudiplk.github.io 设置 添加CNAMA 在hexod的public的文件夹下创建CNAME.txt 填入你的域名（如 www.wudiplk.top)去掉后缀,保存发布到github]]></content>
      <categories>
        <category>Web建站</category>
        <category>搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo优化--添加百度、谷歌搜索站点地图]]></title>
    <url>%2F2018%2F06%2F20%2F20180620Hexo%E4%BC%98%E5%8C%96%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Hexo优化–添加百度、谷歌搜索站点地图 ¶一、什么是站点地图 网站地图，又称站点地图，它就是一个页面，上面放置了网站上需要搜索引擎抓取的所有页面的链接（注：不是所有页面）。大多数人在网站上找不到自己所需要的信息时，可能会将网站地图作为一种补救措施。搜索引擎蜘蛛非常喜欢网站地图。 https://baike.baidu.com/item/网站地图/393478?fr=aladdin ¶二、Hexo如何添加站点地图 nmp 为Hexo提供了相关的插件，我们仅仅需要安装相应的插件就可以。 ¶步骤1：安装插件 谷歌搜索: 1npm install hexo-generator-sitemap --save 百度搜索: 1npm install hexo-generator-baidu-sitemap --save ¶步骤2：生成站点文件 命令 1hexo g -d ¶步骤3：到相应的网站添加站点地图 百度：https://ziyuan.baidu.com/ 谷歌：https://www.google.com/webmasters/tools/home?hl=zh-CN&amp;authuser=0 两者都要进行相关的注册，注册验证好找到相应的添加站点,两者都是要验证网站的所有权（方式有多种，我们选择上传文件方式） 下载指定文件到 hexo 的public文件夹下然后 hexo d 百度操作 谷歌操作]]></content>
      <categories>
        <category>Web建站</category>
        <category>优化</category>
      </categories>
      <tags>
        <tag>Hexo优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F2018%2F06%2F19%2F20180619%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>技术第一</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2FREADME.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[这就是我，你想知道的我 E-Mail:wudiplk@163.com GitHub:github.com/wudiplk MyBlog:www.wudiplk.top 关于名字 😏plk 普朗克常量（6.62607004 × 10-34 m2 kg / s） 关于写个人博客的，纯属闷骚（PS:语文渣渣一枚），也就想写写文章，分享些东西给大家，也总结总结，记录些东西毕竟时间转眼即逝~ Steam 用户 WeGame用户 喜欢玩国产单机游戏 侠客风云传、古剑、仙剑。对于吃鸡等网游、手游真带不起劲儿来来。 心中的游戏神作：仙剑四（把懵懂的我感动了）、文明6(只有永远的下一回合，史诗级巨作、上下五千年有你不知道历史)、塞尔达传说（这个游戏就用说了超级开放的世界，就差和塞尔达公主结婚生孩子了😏，喜欢玩的朋友可以加我好友 喜欢动漫，大部分神作都看过也很喜欢，比如命运石之门、死亡笔记，还有魔法少女小圆（4：3圆脸也这么好看，强力推荐，想看朋友别被他骗了 老虚出品，必属精品，广告一波~） 电影嘛，这个几句话说不玩了了，有空会写一篇关于电影的文章，不管是爱情、科幻、动作都喜欢，言之不尽。 喜欢跑步、羽毛球 音乐吧也就是个木耳~，有空没事也就捣鼓捣鼓电脑、帮同事盆友一键还原bingo]]></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
